% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/misc_and_utility.R
\name{umx_score_scale}
\alias{umx_score_scale}
\title{Score a psychometric scale by summing normal and reversed items.}
\usage{
umx_score_scale(
  base = NULL,
  pos = NULL,
  rev = NULL,
  min = 1,
  max = NULL,
  data = NULL,
  score = c("total", "mean", "max", "factor"),
  name = NULL,
  na.rm = TRUE,
  minManifests = NA,
  alpha = FALSE,
  mapStrings = NULL,
  omegaNfactors = 1,
  verbose = FALSE
)
}
\arguments{
\item{base}{String common to all item names.}

\item{pos}{The positive-scored item numbers.}

\item{rev}{The reverse-scored item numbers.}

\item{min}{Min possible score (default = 1). Not implemented for values other than 1 so far...}

\item{max}{Max possible score for an item (to compute how to reverse items).}

\item{data}{The data frame}

\item{score}{Whether to compute the score total, mean, max, or factor (default = "total")}

\item{name}{= name of the scale to be returned. Defaults to "base_score"}

\item{na.rm}{Whether to delete NAs when computing scores (Default = TRUE) Note: Choice affects mean!}

\item{minManifests}{If score = factor, how many missing items to tolerate for an individual?}

\item{alpha}{print Cronbach's alpha? (TRUE)}

\item{mapStrings}{For recoding input like "No"/"Maybe"/"Yes" to numeric 0,1,2}

\item{omegaNfactors}{nfactors for the omega function (if requesting reliability) (default = 1)}

\item{verbose}{Whether to print the whole omega output (FALSE)}
}
\value{
\itemize{
\item scores
}
}
\description{
Use this function to generate scores as the appropriate sum of responses to the normal and reversed items in a scale.

Items must be named on the pattern \code{baseN}, where \code{base} is the string common to all item (column) names and N is the item number in the scale.

\code{pos} and \code{rev} are vectors of the item numbers for the normal and reverse-scored item numbers.

To reverse items, the function uses \code{max} and \code{min} as the lowest and highest possible response scores to compute how to reverse items.

\emph{note}: \code{min} defaults to 1.
}
\details{
In the presence of NAs, \code{score= "mean"} and \code{score = "totals"} both return NA unless na.rm = TRUE.
\code{score = "max"}, ignores NAs no matter what.
}
\examples{
library(psych)
library(psychTools)
data(bfi)

# ==============================
# = Score Agreeableness totals =
# ==============================

# Handscore subject 1
# A1(R)+A2+A3+A4+A5 = (6+1)-2 +4+3+4+4 = 20

tmp = umx_score_scale("A", pos = 2:5, rev = 1, max = 6, data= bfi, name = "A")
tmp[1, namez(tmp, "A",ignore.case = FALSE)]
#  A1 A2 A3 A4 A5  A
#  2  4  3  4  4  20

# ====================
# = Request the mean =
# ====================
tmp = umx_score_scale("A", pos = 2:5, rev = 1, max = 6, data= bfi, name = "A", score="mean")
tmp$A[1] # = 4

# ==================
# = na.rm = TRUE ! =
# ==================
tmpDF = bfi
tmpDF[1, "A1"] = NA
tmp = umx_score_scale("A", pos = 2:5, rev = 1, max = 6, data= tmpDF, score="mean")
tmp$A_score[1] # 3.75

tmp= umx_score_scale("A", pos= 2:5, rev= 1, max = 6, data = tmpDF,
   score="mean", na.rm=FALSE)
tmp$A_score[1] # NA (reject cases with missing items)

# ===============
# = Score = max =
# ===============
tmp = umx_score_scale("A", pos = 2:5, rev = 1, max = 6,
  data = bfi, name = "A", score = "max")
tmp$A[1] # Subject 1 max = 5 (reversed) item 1

# Default scale name
tmp = umx_score_scale("E", pos = 3:5, rev = 1:2, max = 6, 
   data= tmp, score = "mean", na.rm=FALSE)
tmp$E_score[1]

# Using @BillRevelle's psych package: More diagnostics, including alpha
scores= psych::scoreItems(items = bfi, min = 1, max = 6, keys = list(
	E = c("-E1","-E2", "E3", "E4", "E5"),
	A = c("-A1", "A2", "A3", "A4", "A5")
))
summary(scores)
scores$scores[1, ]
#  E   A 
# 3.8 4.0 

# Compare output
# (note, by default psych::scoreItems replaces NAs with the sample median...)
RevelleE = as.numeric(scores$scores[,"E"])
all(RevelleE == tmp[,"E_score"], na.rm = TRUE)

# =======================
# = MapStrings examples =
# =======================
mapStrings = c(
   "Very Inaccurate", "Moderately Inaccurate", 
   "Slightly Inaccurate", "Slightly Accurate",
   "Moderately Accurate", "Very Accurate")
bfi$As1 = factor(bfi$A1, levels = 1:6, labels = mapStrings)
bfi$As2 = factor(bfi$A2, levels = 1:6, labels = mapStrings)
bfi$As3 = factor(bfi$A3, levels = 1:6, labels = mapStrings)
bfi$As4 = factor(bfi$A4, levels = 1:6, labels = mapStrings)
bfi$As5 = factor(bfi$A5, levels = 1:6, labels = mapStrings)
bfi= umx_score_scale(name="A" , base="A", pos=2:5, rev=1, max=6, data=bfi)
bfi= umx_score_scale(name="As", base="As", pos=2:5, rev=1, mapStrings = mapStrings, data= bfi)
all(bfi$A == bfi$As)

# copes with bad name requests
umx_score_scale(base = "NotPresent", pos=2:5, rev=1, max=6, data=bfi)
}
\seealso{
Other Data Functions: 
\code{\link{noNAs}()},
\code{\link{umxFactor}()},
\code{\link{umxHetCor}()},
\code{\link{umx_as_numeric}()},
\code{\link{umx_cont_2_quantiles}()},
\code{\link{umx_lower2full}()},
\code{\link{umx_make_MR_data}()},
\code{\link{umx_make_TwinData}()},
\code{\link{umx_make_fake_data}()},
\code{\link{umx_make_raw_from_cov}()},
\code{\link{umx_polychoric}()},
\code{\link{umx_polypairwise}()},
\code{\link{umx_polytriowise}()},
\code{\link{umx_read_lower}()},
\code{\link{umx_read_prolific_demog}()},
\code{\link{umx_rename}()},
\code{\link{umx_reorder}()},
\code{\link{umx_select_valid}()},
\code{\link{umx_stack}()},
\code{\link{umx}}
}
\concept{Data Functions}
